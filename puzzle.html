<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Puzzle of Us üß©</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Pacifico&family=Quicksand:wght@400;700&display=swap" rel="stylesheet">
    <style>
        * { box-sizing: border-box; touch-action: manipulation; }
        body, html {
            height: 100%; width: 100%; margin: 0; padding: 0;
            font-family: 'Quicksand', sans-serif;
            background: linear-gradient(135deg, #fbcfe8 0%, #c4b5fd 100%); /* Soft Pink/Purple */
            overflow: hidden;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
        }

        /* --- UI ELEMENTS --- */
        .back-btn {
            position: absolute; top: 20px; left: 20px;
            background: white; padding: 10px 24px; border-radius: 99px;
            color: #ec4899; font-weight: bold; text-decoration: none;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1); z-index: 50;
        }

        .header {
            text-align: center; margin-bottom: 20px; z-index: 10;
        }
        h1 {
            font-family: 'Pacifico', cursive; color: #be185d;
            font-size: clamp(2rem, 5vw, 3rem); 
            text-shadow: 2px 2px 0px white;
        }
        .stats {
            background: rgba(255,255,255,0.5); backdrop-filter: blur(5px);
            padding: 8px 20px; border-radius: 20px; margin-top: 10px;
            font-weight: bold; color: #831843; display: inline-flex; gap: 15px;
        }

        /* --- PUZZLE BOARD --- */
        .puzzle-container {
            width: 90vw; max-width: 400px;
            aspect-ratio: 1/1;
            background: rgba(255,255,255,0.3);
            padding: 10px; border-radius: 15px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
            position: relative;
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            width: 100%; height: 100%;
            gap: 2px;
            border-radius: 8px; overflow: hidden;
            background: #be185d;
        }

        .tile {
            width: 100%; height: 100%;
            background-image: url('images/8.jpg'); /* TARGET IMAGE */
            background-size: 300% 300%; /* 3x3 grid means 300% size */
            cursor: pointer;
            transition: transform 0.2s ease;
            display: flex; align-items: center; justify-content: center;
            font-size: 0; /* Hide numbers usually */
        }
        
        .tile.empty {
            background: transparent;
            cursor: default;
        }

        /* --- CONTROLS --- */
        .controls {
            margin-top: 20px; display: flex; gap: 10px; z-index: 10;
        }
        .btn {
            background: white; color: #ec4899; border: 2px solid #ec4899;
            padding: 10px 20px; border-radius: 99px; font-weight: bold;
            transition: all 0.2s; cursor: pointer;
        }
        .btn:hover { background: #fdf2f8; transform: translateY(-2px); }
        .btn.primary { background: #ec4899; color: white; border: none; }

        /* --- OVERLAYS --- */
        .overlay {
            position: absolute; inset: 0; background: rgba(0,0,0,0.8);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            opacity: 0; pointer-events: none; transition: opacity 0.3s; z-index: 100;
            border-radius: 15px;
        }
        .overlay.show { opacity: 1; pointer-events: auto; }

        /* Hint Overlay (Shows full image) */
        .hint-overlay {
            position: absolute; inset: 0;
            background-image: url('images/8.jpg');
            background-size: cover;
            opacity: 0; pointer-events: none; transition: opacity 0.3s;
            z-index: 20; border-radius: 8px;
        }
        .hint-overlay.show { opacity: 1; }

    </style>
</head>
<body>

    <a href="index.html" class="back-btn">‚¨Ö Back</a>

    <div class="header">
        <h1>Puzzle of Us üß©</h1>
        <div class="stats">
            <span>Moves: <span id="move-count">0</span></span>
            <span>Time: <span id="time-count">00:00</span></span>
        </div>
    </div>

    <div class="puzzle-container">
        <!-- The Grid -->
        <div class="grid" id="grid">
            <!-- Tiles generated by JS -->
        </div>

        <!-- Hint Overlay -->
        <div id="hint" class="hint-overlay"></div>

        <!-- Win Screen -->
        <div id="win-screen" class="overlay">
            <h2 class="font-pacifico text-4xl text-pink-400 mb-2">Solved! üéâ</h2>
            <p class="text-white text-lg mb-6">Kamu menyatukan kita kembali! ‚ù§Ô∏è</p>
            <button class="btn primary" onclick="initGame()">Main Lagi üîÑ</button>
        </div>
    </div>

    <div class="controls">
        <button class="btn" onmousedown="showHint()" onmouseup="hideHint()" ontouchstart="showHint()" ontouchend="hideHint()">üëÅÔ∏è Peek</button>
        <button class="btn primary" onclick="initGame()">üîÄ Shuffle</button>
    </div>

    <script>
        const grid = document.getElementById('grid');
        const moveDisplay = document.getElementById('move-count');
        const timeDisplay = document.getElementById('time-count');
        const winScreen = document.getElementById('win-screen');
        const hintScreen = document.getElementById('hint');

        let tiles = []; // [0, 1, 2, ... 8] representing positions
        let emptyIndex = 8; // The empty tile index (bottom right initially)
        let moves = 0;
        let timer = null;
        let seconds = 0;
        let isPlaying = false;

        // Size 3x3
        const SIZE = 3;

        function initGame() {
            // Reset State
            moves = 0;
            seconds = 0;
            isPlaying = false;
            stopTimer();
            updateStats();
            winScreen.classList.remove('show');

            // Create Solved State
            tiles = Array.from({length: SIZE * SIZE}, (_, i) => i);
            emptyIndex = SIZE * SIZE - 1; // 8

            // Shuffle validly
            shuffleTiles();
            
            // Render
            render();
            startTimer();
            isPlaying = true;
        }

        function shuffleTiles() {
            // To ensure the puzzle is solvable, we simulate random valid moves
            // rather than pure random placement.
            let previousIndex = -1;
            const shuffleMoves = 100;

            for (let i = 0; i < shuffleMoves; i++) {
                const neighbors = getNeighbors(emptyIndex);
                // Don't undo the immediate last move if possible
                const validNeighbors = neighbors.filter(n => n !== previousIndex);
                const randomNeighbor = validNeighbors[Math.floor(Math.random() * validNeighbors.length)];
                
                swap(emptyIndex, randomNeighbor);
                previousIndex = emptyIndex;
                emptyIndex = randomNeighbor;
            }
        }

        function getNeighbors(index) {
            const row = Math.floor(index / SIZE);
            const col = index % SIZE;
            const neighbors = [];

            if (row > 0) neighbors.push(index - SIZE); // Up
            if (row < SIZE - 1) neighbors.push(index + SIZE); // Down
            if (col > 0) neighbors.push(index - 1); // Left
            if (col < SIZE - 1) neighbors.push(index + 1); // Right

            return neighbors;
        }

        function handleTileClick(index) {
            if (!isPlaying) return;

            const neighbors = getNeighbors(emptyIndex);
            if (neighbors.includes(index)) {
                // Valid move
                swap(emptyIndex, index);
                emptyIndex = index;
                moves++;
                updateStats();
                render();
                checkWin();
            }
        }

        function swap(i, j) {
            [tiles[i], tiles[j]] = [tiles[j], tiles[i]];
        }

        function render() {
            grid.innerHTML = '';
            tiles.forEach((tileNumber, index) => {
                const tile = document.createElement('div');
                tile.className = `tile ${tileNumber === SIZE*SIZE - 1 ? 'empty' : ''}`;
                
                if (tileNumber !== SIZE*SIZE - 1) {
                    // Calculate background position based on the original solved position (tileNumber)
                    const row = Math.floor(tileNumber / SIZE);
                    const col = tileNumber % SIZE;
                    // 3x3 grid means percentages are 0%, 50%, 100%
                    const x = col * 50; 
                    const y = row * 50;
                    tile.style.backgroundPosition = `${x}% ${y}%`;
                }

                tile.onclick = () => handleTileClick(index);
                grid.appendChild(tile);
            });
        }

        function checkWin() {
            const isSolved = tiles.every((val, index) => val === index);
            if (isSolved) {
                isPlaying = false;
                stopTimer();
                setTimeout(() => winScreen.classList.add('show'), 300);
            }
        }

        // --- TIMER & UI ---
        function startTimer() {
            stopTimer();
            timer = setInterval(() => {
                seconds++;
                updateStats();
            }, 1000);
        }

        function stopTimer() {
            clearInterval(timer);
        }

        function updateStats() {
            moveDisplay.innerText = moves;
            const mins = Math.floor(seconds / 60).toString().padStart(2, '0');
            const secs = (seconds % 60).toString().padStart(2, '0');
            timeDisplay.innerText = `${mins}:${secs}`;
        }

        function showHint() { hintScreen.classList.add('show'); }
        function hideHint() { hintScreen.classList.remove('show'); }

        // Start on Load
        initGame();

    </script>
</body>
</html>