<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>For You</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <style>
        body {
            margin: 0; padding: 0;
            background-color: #020202; /* Almost pure black */
            overflow: hidden; font-family: sans-serif;
        }
        canvas {
            display: block; position: absolute;
            top: 0; left: 0; z-index: 2;
        }
        #input_video, #image_canvas { display: none; }
        
        #overlay {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: rgba(255,255,255,0.9);
            text-align: center; z-index: 10;
            pointer-events: none;
            background: rgba(0,0,0,0.7);
            padding: 20px 30px; border-radius: 20px;
            transition: opacity 0.5s;
            backdrop-filter: blur(5px);
        }
        .hidden { opacity: 0; }
        h3 { margin: 0 0 15px 0; color: #ffb6c1; }
        p { margin: 5px 0; font-size: 1.1em; }
    </style>
</head>
<body>

    <div id="overlay">
        <h3>Magic Guide</h3>
        <p>‚òùÔ∏è 1 Finger = Muffin</p>
        <p>‚úåÔ∏è 2 Fingers = Pumpkin</p>
        <p>‚úã 4 Fingers = Love</p>
        <p>üñêÔ∏è 5 Fingers = Photo</p>
        <p>‚úä Fist = ‚ù§Ô∏è</p>
        <small style="color: #aaa; display:block; margin-top:15px;">Waiting for camera...</small>
    </div>

    <video id="input_video" playsinline></video>
    <canvas id="output_canvas"></canvas>
    <canvas id="image_canvas"></canvas>

<script>
    // --- CONFIGURATION ---
    // MAKE SURE THIS PATH IS CORRECT
    const IMAGE_URL = 'images/88.jpg'; 
    
    // Increased significantly for denser, cleaner shapes
    const PARTICLE_COUNT = 1800; 
    const SCAN_DETAIL = 3; // Lower = denser text scanning (was 6)

    const videoElement = document.getElementById('input_video');
    const canvasElement = document.getElementById('output_canvas');
    const canvasCtx = canvasElement.getContext('2d');
    const imageCanvas = document.getElementById('image_canvas');
    const imageCtx = imageCanvas.getContext('2d');
    const overlay = document.getElementById('overlay');

    let width = window.innerWidth;
    let height = window.innerHeight;
    canvasElement.width = width;
    canvasElement.height = height;

    let particles = [];
    // Possible states: 'muffin', 'pumpkin', 'love', 'heart', 'photo', 'none'
    let currentGesture = 'none'; 
    
    // Point Clouds
    let pointsMuffin = [];
    let pointsPumpkin = [];
    let pointsLove = [];
    let pointsHeart = [];
    let pointsPhoto = []; 

    // --- LOAD IMAGE ---
    const targetImage = new Image();
    targetImage.crossOrigin = "Anonymous";
    targetImage.src = IMAGE_URL;
    targetImage.onload = () => {
        console.log("Image Loaded Success");
        generatePhotoPoints();
    };
    targetImage.onerror = () => {
        console.error("IMAGE NOT FOUND AT:", IMAGE_URL);
        alert("Image not found! Check the file path inside the script.");
    }

    // --- PARTICLE SYSTEM ---
    class Particle {
        constructor() {
            this.x = Math.random() * width;
            this.y = Math.random() * height;
            // Slower floating speed for calmness
            this.vx = (Math.random() - 0.5) * 1;
            this.vy = (Math.random() - 0.5) * 1;
            this.size = Math.random() * 2 + 1; // Slightly varied size
            this.baseColor = "rgba(255, 255, 255, ";
            this.opacity = 0.5;
            this.targetX = null;
            this.targetY = null;
            this.targetRgb = null;
            this.assignedGesture = 'none';
        }

        update() {
            // 1. Check for Gesture Change
            // If the global gesture changed, release this particle from its old target
            if (this.assignedGesture !== currentGesture) {
                this.targetX = null;
                this.assignedGesture = currentGesture;
            }

            let targetList = null;
            let snapSpeed = 0.12; // How fast they snap to position

            // Select Point Cloud based on gesture
            if (currentGesture === 'muffin') targetList = pointsMuffin;
            else if (currentGesture === 'pumpkin') targetList = pointsPumpkin;
            else if (currentGesture === 'love') targetList = pointsLove;
            else if (currentGesture === 'heart') targetList = pointsHeart;
            else if (currentGesture === 'photo') targetList = pointsPhoto;

            // --- SHAPE FORMING BEHAVIOR ---
            if (targetList && targetList.length > 0) {
                // Only assign a NEW target if we don't have one yet.
                // This stops the jittering/swarming effect.
                if (this.targetX === null) { 
                    const pt = targetList[Math.floor(Math.random() * targetList.length)];
                    this.targetX = pt.x;
                    this.targetY = pt.y;
                    
                    // Color assignment based on gesture
                    if (currentGesture === 'photo') {
                        this.targetRgb = `${pt.r},${pt.g},${pt.b}`;
                        this.opacity = 0.9; // Opaque for photos
                        snapSpeed = 0.15; // Faster snap for photos
                    } else if (currentGesture === 'heart') {
                        this.targetRgb = "255, 50, 80"; // Red
                        this.opacity = 0.9;
                    } else if (currentGesture === 'love') {
                         this.targetRgb = "255, 105, 180"; // Hot Pink
                         this.opacity = 0.9;
                    } else if (currentGesture === 'pumpkin') {
                        this.targetRgb = "255, 165, 0"; // Orange
                        this.opacity = 0.9;
                    } else if (currentGesture === 'muffin') {
                        this.targetRgb = "135, 206, 235"; // Sky Blue
                        this.opacity = 0.9;
                    }
                }

                // Smooth movement towards target (Erease function)
                this.x += (this.targetX - this.x) * snapSpeed;
                this.y += (this.targetY - this.y) * snapSpeed;

            } 
            // --- FREE FLOATING BEHAVIOR ---
            else {
                this.x += this.vx;
                this.y += this.vy;
                
                // Bounce off screen edges
                if (this.x < 0 || this.x > width) this.vx *= -1;
                if (this.y < 0 || this.y > height) this.vy *= -1;
                
                // Dim color when floating randomly
                this.targetRgb = "255, 255, 255";
                this.opacity = 0.3;
            }
        }

        draw() {
            canvasCtx.beginPath();
            canvasCtx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
            // Dynamically set color and opacity
            canvasCtx.fillStyle = this.baseColor + this.opacity + ")";
            if (this.targetRgb) {
                 canvasCtx.fillStyle = `rgba(${this.targetRgb}, ${this.opacity})`;
            }
            canvasCtx.fill();
        }
    }

    // --- POINT GENERATORS (The Architects) ---
    
    // 1. TEXT GENERATOR (Makes words denser)
    function generateTextPoints(text, array) {
        const tCanvas = document.createElement('canvas');
        tCanvas.width = width; height = height;
        const tCtx = tCanvas.getContext('2d');
        
        // Big, bold font centered on screen
        let fontSize = Math.min(width/text.length * 1.5, height/3);
        tCtx.font = `900 ${fontSize}px sans-serif`;
        tCtx.fillStyle = "white";
        tCtx.textAlign = "center"; tCtx.textBaseline = "middle";
        tCtx.fillText(text, width / 2, height / 2);

        const imgData = tCtx.getImageData(0, 0, width, height).data;
        array.length = 0; 

        // Scan for pixels. SCAN_DETAIL = 3 means check every 3rd pixel (denser)
        for (let y = 0; y < height; y += SCAN_DETAIL) {
            for (let x = 0; x < width; x += SCAN_DETAIL) {
                if (imgData[(y * width + x) * 4 + 3] > 128) {
                    array.push({x, y});
                }
            }
        }
    }

    // 2. HEART GENERATOR
    function generateHeartPoints() {
        pointsHeart = [];
        for (let t = 0; t < Math.PI * 2; t += 0.04) { // 0.04 step for smoother heart
            let x = 16 * Math.pow(Math.sin(t), 3);
            let y = -(13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t));
            let scale = Math.min(width, height) / 30; 
            pointsHeart.push({
                x: x * scale + width / 2,
                y: y * scale + height / 2
            });
        }
    }

    // 3. PHOTO GENERATOR
    function generatePhotoPoints() {
        if (!targetImage.src || targetImage.width === 0) return;
        
        // Fit image nicely on screen
        let iWidth = Math.min(width * 0.9, 600); 
        let scale = iWidth / targetImage.width;
        let iHeight = targetImage.height * scale;

        imageCanvas.width = width; imageCanvas.height = height;
        imageCtx.drawImage(targetImage, (width - iWidth)/2, (height - iHeight)/2, iWidth, iHeight);
        
        const data = imageCtx.getImageData(0, 0, width, height).data;
        pointsPhoto = [];

        // Scan photo pixels. Denser scan for better resolution.
        const step = SCAN_DETAIL + 1; 
        for (let y = 0; y < height; y += step) {
            for (let x = 0; x < width; x += step) {
                const i = (y * width + x) * 4;
                if (data[i+3] > 128) { 
                    pointsPhoto.push({ x, y, r: data[i], g: data[i+1], b: data[i+2] });
                }
            }
        }
    }

    // --- MAIN LOOPS ---
    function init() {
        particles = [];
        // Create the massive particle pool
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            particles.push(new Particle());
        }
        
        // Pre-calculate shape positions
        generateTextPoints("Muffin", pointsMuffin);
        generateTextPoints("Pumpkin", pointsPumpkin);
        generateTextPoints("Love", pointsLove);
        generateHeartPoints();
        if(targetImage.complete) generatePhotoPoints();
    }

    function animate() {
        // Use semi-transparent clear for slight trail effect (optional, change 0.3 to 1 for no trails)
        canvasCtx.fillStyle = 'rgba(2, 2, 2, 0.3)';
        canvasCtx.fillRect(0, 0, width, height);
        // canvasCtx.clearRect(0,0,width,height); // Use this line instead if you want zero trails

        particles.forEach(p => { p.update(); p.draw(); });
        requestAnimationFrame(animate);
    }

    // --- HAND GESTURE RECOGNITION ---
    function onResults(results) {
        // Hide overlay on first detection
        if(overlay && !overlay.classList.contains('hidden') && results.multiHandLandmarks.length > 0) {
             overlay.classList.add('hidden');
        }

        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const lm = results.multiHandLandmarks[0];
            
            // Finger States (Is tip higher than middle joint?)
            // Note: Y axis is inverted (0 is top of screen)
            const indexUp = lm[8].y < lm[6].y;
            const middleUp = lm[12].y < lm[10].y;
            const ringUp = lm[16].y < lm[14].y;
            const pinkyUp = lm[20].y < lm[18].y;
            // Thumb is tricky. Check if tip is far from base of index finger relative to hand width
            const thumbUp = Math.abs(lm[4].x - lm[2].x) > Math.abs(lm[3].x - lm[17].x) * 0.5;

            let fingersUpCount = 0;
            if (indexUp) fingersUpCount++;
            if (middleUp) fingersUpCount++;
            if (ringUp) fingersUpCount++;
            if (pinkyUp) fingersUpCount++;
            if (thumbUp) fingersUpCount++;
            
            // --- GESTURE MAPPING ---
            
            // FIST (0 fingers) -> Heart
            if (fingersUpCount === 0 || (fingersUpCount === 1 && thumbUp)) {
                 currentGesture = 'heart';
            }
            // 1 FINGER (Index) -> Muffin
            else if (fingersUpCount === 1 && indexUp) {
                currentGesture = 'muffin';
            }
             // 2 FINGERS (Peace) -> Pumpkin
            else if (fingersUpCount === 2 && indexUp && middleUp) {
                currentGesture = 'pumpkin';
            }
            // 4 FINGERS -> Love
            else if (fingersUpCount === 4 && !thumbUp) {
                 currentGesture = 'love';
            }
            // 5 FINGERS (Open Hand) -> Photo
            else if (fingersUpCount === 5) {
                currentGesture = 'photo';
            }
            // Transition state
            else {
                // Optional: Keep last gesture or reset to none. Resetting feels snappier.
                // currentGesture = 'none'; 
            }

        } else {
            currentGesture = 'none';
        }
    }

    // --- MEDIAPIPE SETUP ---
    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 0, // Lite model for speed
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
    });
    hands.onResults(onResults);

    const camera = new Camera(videoElement, {
        onFrame: async () => await hands.send({image: videoElement}),
        width: 640, height: 480, facingMode: "user" // Slightly higher res input for better finger counting
    });
    camera.start();

    // Handle window resize
    window.addEventListener('resize', () => {
        width = window.innerWidth; height = window.innerHeight;
        canvasElement.width = width; canvasElement.height = height;
        init(); 
    });

    init();
    animate();

</script>
</body>
</html>